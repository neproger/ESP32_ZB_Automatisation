# Архитектура приложения ESP32‑панели

Документ описывает целевую архитектуру приложения в терминах:

- глобальных состояний приложения;
- событийной шины (`app_events`);
- ролей модулей (main, UI, транспорт, state_manager);
- принципов: где прямой вызов, где события.

Некоторые вещи уже реализованы в коде, часть — целевое направление для постепенного рефакторинга.

---

## 1. Общие принципы

### 1.1. AppMain как контроллер

Мы рассматриваем `app_main` как единственный "дирижёр" приложения:

- именно здесь принимаются глобальные решения:
  - когда входить в config‑режим (AP + HTTP UI);
  - когда начинать/повторять bootstrap состояния из HA;
  - когда считать, что система перешла в нормальный режим работы;
  - когда включать/выключать скринсейвер/подсветку/сон (в перспективе).
- все остальные модули (UI, транспорт, state_manager, devices) ведут себя как "сервисы":
  - публикуют события‑факты о своём состоянии;
  - выполняют команды (через события‑команды или прямые вызовы);
  - не принимают глобальных решений сами.

Таким образом, архитектура строится вокруг **одной точки принятия решений** и набора модулей‑исполнителей.

### 1.2. События vs прямые вызовы

Чтобы избежать "супа" из парадигм, вводим чёткий критерий:

- **События** (`app_events`):
  - используются для передачи фактов и управляющих команд;
  - источник события не знает, кто именно на него реагирует;
  - событий может быть несколько подписчиков;
  - обработка может происходить асинхронно.

- **Прямые вызовы функций**:
  - используются для обращения "вниз по слоям" к конкретному сервису,
    когда вызывающий точно знает, кого и зачем дернуть;
  - важен синхронный результат (`http_manager::bootstrap_state()`, `devices_init()`, `config_store::init()`);
  - такие вызовы концентрируем в `app_main` (контроллер) и минимально в "сервисных" модулях.

Направление потоков:

- **вверх (из модулей к контроллеру)** — только события‑факты;
- **вниз (от контроллера к модулям)** — события‑команды + прямые вызовы сервисов.

---

## 2. Глобальное состояние приложения (AppState)

Цель — иметь одну явную машину состояний, описывающую режим приложения.

Предлагаемый enum (живёт в `main/main.cpp` рядом с `app_main`):

```cpp
enum class AppState {
    BootDevices,      // инициализация дисплея, тача, LVGL
    BootWifi,         // запуск Wi‑Fi стека, NVS, базовый конфиг
    BootBootstrap,    // bootstrap состояния из HA
    NormalAwake,      // обычная работа: UI комнат, MQTT, подсветка включена
    NormalScreensaver,// показ скринсейвера (подсветка включена)
    NormalSleep,      // скринсейвер, подсветка/панель выключены, возможен light sleep
    ConfigMode,       // режим точки доступа + HTTP веб‑настройка
};
```

Переменная:

```cpp
static AppState g_app_state = AppState::BootDevices;
```

Ключевая идея: любое "глобальное" решение (перейти в config, включить скринсейвер, уйти в sleep) выражается как **смена AppState плюс рассылка команд**.

---

## 3. Событийная шина `app_events`

Все события проходят через `APP_EVENTS` (`main/app/app_events.hpp/.cpp`).

### 3.1. События‑факты

То, что *произошло* в мире:

- `KNOB`, `BUTTON`, `GESTURE` — входные устройства;
- `NAVIGATE_ROOM` — навигация между комнатами;
- `ENTITY_STATE_CHANGED` — изменилось состояние сущности в `state_manager`;
- `WAKE_SCREENSAVER` — "разбудить" скринсейвер по нажатию/жесту;
- потенциально: `IDLE_TICK` (`inactive_ms`), `BOOTSTRAP_DONE`, `WIFI_CONNECTED` и т.д.

Факты **не содержат решений**, только данные: "вот что случилось, разберитесь".

### 3.2. События‑команды

То, что контроллер говорит модулям *сделать*:

- существующие команды UI/логики:
  - `TOGGLE_CURRENT_ENTITY` — переключить текущую сущность;
  - `TOGGLE_REQUEST`/`TOGGLE_RESULT` — команда/результат переключения конкретной сущности;
- целевые команды для управления режимами (предлагаемые):
  - `CMD_SHOW_SCREENSAVER`
  - `CMD_HIDE_SCREENSAVER`
  - `CMD_DIM_BACKLIGHT`
  - `CMD_WAKE_BACKLIGHT`
  - `CMD_ENTER_CONFIG`
  - `CMD_START_MQTT`
  - `CMD_START_UI`

Команды **не рождаются в модулях‑листьях** (UI/транспорт), их публикует только контроллер (app_main).

---

## 4. Роли основных модулей

### 4.1. main/main.cpp (контроллер)

Главная ответственность:

- держит `AppState` и глобальные флаги;
- последовательно выполняет bootstrap:
  - `devices_init()`;
  - `wifi_manager_init()` + `config_store::init()`;
  - `http_manager::bootstrap_state()` (с возможными ретраями);
  - запуск `router::start()` и `http_manager::start_weather_polling()`;
  - запуск UI (`ui::screensaver::init_support()`, `ui_app_init()`);
- управляет сплэшем (`ui::splash::show/update_state/destroy`);
- принимает решение о входе в режим настройки (`enter_config_mode()`);
- (целевое состояние) — рулит скринсейвером/подсветкой на основе `inactive_ms` (через событийный контроллер).

`enter_config_mode()` — единственное место, где включается AP + конфиг‑сервер и "паркуется" основной поток.

### 4.2. ui/splash.*

Отвечает только за экран загрузки:

- `show(ConfigCallback on_config)` — показывает сплэш и, опционально, регистрирует callback для кнопки "настроить";
- `update_state(int percent, const char *text)` — обновляет прогресс и текст состояния;
- `destroy()` — убирает сплэш, когда UI готов.

Логика режима настройки:

- кнопка "настроить" вызывает переданный callback (например, `enter_config_mode()` из main);
- сам `splash` **не знает**, что такое config mode — он только вызывает callback, когда UI‑событие (нажатие кнопки) это требует.

### 4.3. ui/screensaver.*

Целевая роль скринсейвера — **чистый UI‑модуль, не принимающий решений**:

- публичные функции:
  - `ui::screensaver::init_support()` — создаёт объекты, таймер обновления времени/погоды и подключает необходимые handlers;
  - `show()` — показывает экран скринсейвера;
  - `hide_to_room(lv_obj_t *room_root)` — возвращает к экрану комнаты;
  - `ui_update_weather_and_clock()` — отрисовывает время/дату/погоду;
- больше **не** должно быть:
  - принятия решений на основе `inactive_ms` (idle‑таймер);
  - прямого входа в light sleep/выключения подсветки по собственному усмотрению.

Идеальный вариант (к которому мы идём):

- `screensaver.cpp` подписывается на события‑команды:
  - `CMD_SHOW_SCREENSAVER` → `show()`;
  - `CMD_HIDE_SCREENSAVER` → `hide_to_room(...)` (через текущую room‑страницу);
  - `CMD_DIM_BACKLIGHT` → `devices_display_set_enabled(false)`;
  - `CMD_WAKE_BACKLIGHT` → `devices_display_set_enabled(true)`.
- Модуль сам не считает idle‑время — ему только говорят, что делать.

### 4.4. ui/rooms.*

Роль:

- строит экраны комнат на основе `state::areas()` и `state::entities()`;
- реагирует на события:
  - `NAVIGATE_ROOM` (листать комнаты);
  - `WAKE_SCREENSAVER` (переход со скринсейвера в room);
  - `ENTITY_STATE_CHANGED` (обновляет отображение свитчей);
- генерит локальные UI‑события (жесты, нажатия) в виде `app_events` (`NAVIGATE_ROOM` и др.).

Важно: `rooms` **не** решает, когда включать скринсейвер/сон — он только:

- "будит" по событию `WAKE_SCREENSAVER`;
- выполняет навигацию и визуальные обновления.

### 4.5. transport/http_manager.* и router/ha_mqtt.*

Транспорт:

- `http_manager`:
  - умеет делать bootstrap (`bootstrap_state()`);
  - умеет периодически подтягивать погоду;
  - не решает, что делать при провале bootstrap — это делает контроллер в `main`.

- `router`/`ha_mqtt`:
  - подписывается на MQTT‑топики;
  - публикует события в `state_manager` (`set_entity_state`) и `app_events`;
  - не принимает решений о режимах (config, sleep, screensaver).

### 4.6. app/state_manager.*

Роль:

- хранит данные о `Area`, `Entity`, погоде, часах;
- предоставляет API: `init_from_csv`, `set_entity_state`, `weather()`, `clock()`, `subscribe_entity()`;
- публикует `ENTITY_STATE_CHANGED` через `app_events` (через `app_events::post_entity_state_changed`);
- **не** знает про UI/скринсейвер/режимы — только состояние и события о его изменении.

---

## 5. Логика скринсейвера через AppState (план)

Целевая схема управления скринсейвером в терминах AppState и событий:

1. В `app_main` создаётся FreeRTOS‑таймер или задача `idle_controller`, которая:
   - периодически (например, каждые 500 мс) делает:
     ```cpp
     lvgl_port_lock(0);
     lv_display_t *disp = lv_display_get_default();
     uint32_t inactive_ms = disp ? lv_display_get_inactive_time(disp) : 0;
     lvgl_port_unlock();
     ```
   - вызывает локальную функцию `update_idle_state(inactive_ms)`.

2. `update_idle_state` реализует простую машину состояний:

   ```cpp
   static void update_idle_state(uint32_t inactive_ms)
   {
       switch (g_app_state) {
       case AppState::NormalAwake:
           if (inactive_ms >= kScreensaverTimeoutMs) {
               // перейти в режим скринсейвера
               g_app_state = AppState::NormalScreensaver;
               app_events::post_cmd_show_screensaver(...);
           }
           break;

       case AppState::NormalScreensaver:
           if (inactive_ms >= kScreensaverTimeoutMs + kBacklightOffAfterScreensaverMs) {
               g_app_state = AppState::NormalSleep;
               app_events::post_cmd_dim_backlight(...);
               // при желании: app_events::post_cmd_enter_light_sleep(...);
           }
           break;

       case AppState::NormalSleep:
           // по активности (inactive_ms снова маленькое) или по WAKE‑событию
           // контроллер переведёт состояние обратно в NormalAwake и пошлёт
           // CMD_WAKE_BACKLIGHT + CMD_HIDE_SCREENSAVER.
           break;

       default:
           break;
       }
   }
   ```

3. Сами команды (`CMD_SHOW_SCREENSAVER`, `CMD_DIM_BACKLIGHT`, ...) реализуются либо как отдельные события в `app_events`, либо как прямые вызовы из `main` в `screensaver`/`devices_init` — это деталь реализации, но принцип один: **решения в контроллере**, действия в модулях.

---

## 6. Резюме: как писать новый код

Чтобы новый код вписывался в архитектуру, полезно придерживаться набора простых правил:

1. Если модуль хочет "рассказать" о факте (кнопка, жест, сетевое событие) — он публикует **событие‑факт** через `app_events`, не держа других модулей напрямую.
2. Если нужно изменить глобальный режим/поведение (включить скринсейвер, перейти в config, запустить MQTT) — решение принимается в `app_main` (контроллер), и он:
   - либо публикует **событие‑команду** (`CMD_*`),
   - либо делает прямой вызов в сервисный модуль (HTTP, NVS, devices).
3. UI‑модули (`splash`, `screensaver`, `rooms`) не решают режимы приложения — они только:
   - отображают состояние;
   - генерируют UI‑события;
   - выполняют команды.
4. `state_manager` и транспорт (`http_manager`, `router`) ничего не знают про UI, только про состояние и события состояния.

Следуя этим правилам, можно постепенно привести текущий "суп из парадигм" к прозрачной и читаемой структуре, в которой вся высокоуровневая логика видна в одном месте (`main.cpp`), а остальные файлы остаются локальными и предсказуемыми.

---

## 7. Обратная связь и возможные упрощения

Этот раздел фиксирует идеи упрощения архитектуры, которые можно внедрять по мере развития проекта.

### 7.1. Упрощение команд для скринсейвера

Вместо набора отдельных команд:

- `CMD_SHOW_SCREENSAVER`
- `CMD_HIDE_SCREENSAVER`
- `CMD_DIM_BACKLIGHT`
- `CMD_WAKE_BACKLIGHT`

можно использовать одну более общую команду вида:

```cpp
enum class UiMode { RoomView, Screensaver, Sleep };
// или
// CMD_SET_MODE(UiMode)
```

Тогда:

- контроллер меняет `AppState` и/или `UiMode`;
- UI и подсветка реагируют на новый режим внутри своих модулей (экран, backlight);
- количество команд уменьшается, логика становится проще прослеживаемой.

Пока в коде используются более "гранулярные" команды, но при росте сложности можно перейти к единой команде `SET_MODE` и иметь один обработчик, который расставляет нужные вызовы по UI/устройствам.

### 7.2. Унификация модели событий

Сейчас факты и команды представлены разными enum’ами и структурами. Это удобно на старте, но при росте количества событий (30–40 и более) может стать шумным.

Возможное упрощение на будущее — ввести унифицированную модель события:

```cpp
enum class EventKind { Fact, Command };
enum class EventCode : int32_t; // KNOB, BUTTON, CMD_SET_MODE, ...

struct AppEvent {
    EventKind kind;
    EventCode code;
    void*     payload; // или std::variant / union
};
```

Плюсы такого подхода:

- единообразное логирование и трассировка событий;
- проще добавлять новые типы, не раздувая интерфейс;
- потенциально можно сериализовать события (для отладки/телеметрии).

На текущем этапе это не обязательно; достаточно придерживаться разделения на факты и команды концептуально. Унификация структуры событий — шаг, который можно сделать позже, если шина `app_events` станет насыщенной.

### 7.3. Разделение "экрана" и "расположения экранов"

Сейчас модуль `rooms` выполняет сразу несколько ролей:

- хранит RoomPage’ы и их корневые объекты;
- управляет переходами между комнатами;
- участвует в переходах со скринсейвера (`hide_to_room`).

В будущем можно ввести отдельный модуль, например `ui/layout_manager.*`, который будет отвечать за:

- текущий активный экран (splash / rooms / screensaver / другие);
- переключение между экранами (в ответ на `NAVIGATE_ROOM`, `CMD_SHOW_SCREENSAVER` и т.п.);
- единое место, где решается, какой экран сейчас "на сцене".

Тогда:

- `screensaver`, `rooms`, `splash` станут просто наборами функций для создания/обновления своих экранов;
- логика "показать/скрыть экран" сосредоточится в одном месте;
- упрощается жизненный цикл экранов и освобождение ресурсов.

Это не обязательное изменение "прямо сейчас", но хороший ориентир, если UI будет расти.
